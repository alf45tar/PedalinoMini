import{ESP32ROM as E}from"./esp32-DlivVhIs.js";import"./rom-B2LvkjpK.js";class _ extends E{constructor(){super(...arguments),this.CHIP_NAME="ESP32-P4",this.IMAGE_CHIP_ID=18,this.IROM_MAP_START=1073741824,this.IROM_MAP_END=1275068416,this.DROM_MAP_START=1073741824,this.DROM_MAP_END=1275068416,this.BOOTLOADER_FLASH_OFFSET=8192,this.CHIP_DETECT_MAGIC_VALUE=[0,182303440],this.UART_DATE_REG_ADDR=1343004812,this.EFUSE_BASE=1343410176,this.EFUSE_BLOCK1_ADDR=this.EFUSE_BASE+68,this.MAC_EFUSE_REG=this.EFUSE_BASE+68,this.SPI_REG_BASE=1342754816,this.SPI_USR_OFFS=24,this.SPI_USR1_OFFS=28,this.SPI_USR2_OFFS=32,this.SPI_MOSI_DLEN_OFFS=36,this.SPI_MISO_DLEN_OFFS=40,this.SPI_W0_OFFS=88,this.EFUSE_RD_REG_BASE=this.EFUSE_BASE+48,this.EFUSE_PURPOSE_KEY0_REG=this.EFUSE_BASE+52,this.EFUSE_PURPOSE_KEY0_SHIFT=24,this.EFUSE_PURPOSE_KEY1_REG=this.EFUSE_BASE+52,this.EFUSE_PURPOSE_KEY1_SHIFT=28,this.EFUSE_PURPOSE_KEY2_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY2_SHIFT=0,this.EFUSE_PURPOSE_KEY3_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY3_SHIFT=4,this.EFUSE_PURPOSE_KEY4_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY4_SHIFT=8,this.EFUSE_PURPOSE_KEY5_REG=this.EFUSE_BASE+56,this.EFUSE_PURPOSE_KEY5_SHIFT=12,this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT_REG=this.EFUSE_RD_REG_BASE,this.EFUSE_DIS_DOWNLOAD_MANUAL_ENCRYPT=1<<20,this.EFUSE_SPI_BOOT_CRYPT_CNT_REG=this.EFUSE_BASE+52,this.EFUSE_SPI_BOOT_CRYPT_CNT_MASK=7<<18,this.EFUSE_SECURE_BOOT_EN_REG=this.EFUSE_BASE+56,this.EFUSE_SECURE_BOOT_EN_MASK=1<<20,this.PURPOSE_VAL_XTS_AES256_KEY_1=2,this.PURPOSE_VAL_XTS_AES256_KEY_2=3,this.PURPOSE_VAL_XTS_AES128_KEY=4,this.SUPPORTS_ENCRYPTED_FLASH=!0,this.FLASH_ENCRYPTED_WRITE_ALIGN=16,this.MEMORY_MAP=[[0,65536,"PADDING"],[1073741824,1275068416,"DROM"],[1341128704,1341784064,"DRAM"],[1341128704,1341784064,"BYTE_ACCESSIBLE"],[1337982976,1338114048,"DROM_MASK"],[1337982976,1338114048,"IROM_MASK"],[1073741824,1275068416,"IROM"],[1341128704,1341784064,"IRAM"],[1343258624,1343291392,"RTC_IRAM"],[1343258624,1343291392,"RTC_DRAM"],[1611653120,1611661312,"MEM_INTERNAL2"]],this.UF2_FAMILY_ID=1026592404,this.EFUSE_MAX_KEY=5,this.KEY_PURPOSES={0:"USER/EMPTY",1:"ECDSA_KEY",2:"XTS_AES_256_KEY_1",3:"XTS_AES_256_KEY_2",4:"XTS_AES_128_KEY",5:"HMAC_DOWN_ALL",6:"HMAC_DOWN_JTAG",7:"HMAC_DOWN_DIGITAL_SIGNATURE",8:"HMAC_UP",9:"SECURE_BOOT_DIGEST0",10:"SECURE_BOOT_DIGEST1",11:"SECURE_BOOT_DIGEST2",12:"KM_INIT_KEY"}}async getPkgVersion(E){const _=this.EFUSE_BLOCK1_ADDR+8;return await E.readReg(_)>>27&7}async getMinorChipVersion(E){const _=this.EFUSE_BLOCK1_ADDR+8;return await E.readReg(_)>>0&15}async getMajorChipVersion(E){const _=this.EFUSE_BLOCK1_ADDR+8;return await E.readReg(_)>>4&3}async getChipDescription(E){return`${0===await this.getPkgVersion(E)?"ESP32-P4":"unknown ESP32-P4"} (revision v${await this.getMajorChipVersion(E)}.${await this.getMinorChipVersion(E)})`}async getChipFeatures(E){return["High-Performance MCU"]}async getCrystalFreq(E){return 40}async getFlashVoltage(E){}async overrideVddsdio(E){E.debug("VDD_SDIO overrides are not supported for ESP32-P4")}async readMac(E){let _=await E.readReg(this.MAC_EFUSE_REG);_>>>=0;let S=await E.readReg(this.MAC_EFUSE_REG+4);S=S>>>0&65535;const t=new Uint8Array(6);return t[0]=S>>8&255,t[1]=255&S,t[2]=_>>24&255,t[3]=_>>16&255,t[4]=_>>8&255,t[5]=255&_,this._d2h(t[0])+":"+this._d2h(t[1])+":"+this._d2h(t[2])+":"+this._d2h(t[3])+":"+this._d2h(t[4])+":"+this._d2h(t[5])}async getFlashCryptConfig(E){}async getSecureBootEnabled(E){return await E.readReg(this.EFUSE_SECURE_BOOT_EN_REG)&this.EFUSE_SECURE_BOOT_EN_MASK}async getKeyBlockPurpose(E,_){if(_<0||_>this.EFUSE_MAX_KEY)return void E.debug(`Valid key block numbers must be in range 0-${this.EFUSE_MAX_KEY}`);const S=[[this.EFUSE_PURPOSE_KEY0_REG,this.EFUSE_PURPOSE_KEY0_SHIFT],[this.EFUSE_PURPOSE_KEY1_REG,this.EFUSE_PURPOSE_KEY1_SHIFT],[this.EFUSE_PURPOSE_KEY2_REG,this.EFUSE_PURPOSE_KEY2_SHIFT],[this.EFUSE_PURPOSE_KEY3_REG,this.EFUSE_PURPOSE_KEY3_SHIFT],[this.EFUSE_PURPOSE_KEY4_REG,this.EFUSE_PURPOSE_KEY4_SHIFT],[this.EFUSE_PURPOSE_KEY5_REG,this.EFUSE_PURPOSE_KEY5_SHIFT]],[t,i]=S[_];return await E.readReg(t)>>i&15}async isFlashEncryptionKeyValid(E){const _=[];for(let S=0;S<=this.EFUSE_MAX_KEY;S++){const t=await this.getKeyBlockPurpose(E,S);_.push(t)}if(void 0!==typeof _.find((E=>E===this.PURPOSE_VAL_XTS_AES128_KEY)))return!0;const S=_.find((E=>E===this.PURPOSE_VAL_XTS_AES256_KEY_1)),t=_.find((E=>E===this.PURPOSE_VAL_XTS_AES256_KEY_2));return void 0!==typeof S&&void 0!==typeof t}}export{_ as ESP32P4ROM};
